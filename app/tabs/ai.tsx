// app/(tabs)/ai.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  Pressable,
  KeyboardAvoidingView,
  Platform,
  FlatList,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { Colors } from "../../lib/colors";
import ChatBubble from "../../components/ChatBubble";
import { callAI, type Message } from "../../lib/ai.local";
import { loadJSON, saveJSON, ONBOARD_KEY, type OnboardingData } from "../../lib/storage";

/* ------------------------------- Error Boundary ------------------------------ */
class ErrorBoundary extends React.Component<{ children: React.ReactNode }, { err?: any }> {
  constructor(props: any) { super(props); this.state = {}; }
  static getDerivedStateFromError(err: any) { return { err }; }
  componentDidCatch(err: any, info: any) { console.error("AI screen error:", err, info); }
  render() {
    if ((this.state as any).err) {
      return (
        <View style={{ flex: 1, padding: 16, backgroundColor: Colors.bg }}>
          <Text style={{ fontSize: 18, fontWeight: "800", color: Colors.text }}>Something went wrong</Text>
          <Text style={{ color: Colors.subtext, marginTop: 8 }}>
            {String((this.state as any).err?.message ?? (this.state as any).err)}
          </Text>
        </View>
      );
    }
    return this.props.children;
  }
}

/* ---------------------------------- i18n ---------------------------------- */
const LANGS = ["English", "рдиреЗрдкрд╛рд▓реА", "╪з╪▒╪п┘И", "ржмрж╛ржВрж▓рж╛", "рд╣рд┐рдиреНрджреА"] as const;
type Lang = (typeof LANGS)[number];

const L10N: Record<
  Lang,
  {
    title: string;
    subtitle: string;
    placeholder: string;
    greeting: string;
    aiBusy: string;
    fallback: string;
  }
> = {
  English: {
    title: "Offklass AI",
    subtitle: "Ask questions. Get friendly help.",
    placeholder: "Type your questionтАж",
    greeting: "Hi! IтАЩm Offklass AI. Tell me your grade and what youтАЩd like to learn today ЁЯдЧ",
    aiBusy: "тЪая╕П AI is busy. Try again!",
    fallback: "I couldnтАЩt think of an answer ЁЯШЕ",
  },
  рдиреЗрдкрд╛рд▓реА: {
    title: "рдЕрдлрдХреНрд▓рд╛рд╕ рдПрдЖрдИ",
    subtitle: "рдкреНрд░рд╢реНрди рд╕реЛрдзреНрдиреБрд╣реЛрд╕реНред рд╕рдЬрд┐рд▓реИ рд╕рд╣рдпреЛрдЧ рдкрд╛рдЙрдиреБрд╣реЛрд╕реНред",
    placeholder: "рдЖрдлреНрдиреЛ рдкреНрд░рд╢реНрди рдЯрд╛рдЗрдк рдЧрд░реНрдиреБрд╣реЛрд╕реНтАж",
    greeting: "рдирдорд╕реНрддреЗ! рдо Offklass AI рд╣реБрдБред рдЖрдлреНрдиреЛ рдХрдХреНрд╖рд╛ рд░ рдЖрдЬ рдХреЗ рд╕рд┐рдХреНрди рдЪрд╛рд╣рдиреБрд╣реБрдиреНрдЫ рднрдиреНрдиреБрд╣реЛрд╕реН ЁЯдЧ",
    aiBusy: "тЪая╕П рдПрдЖрдИ рд╡реНрдпрд╕реНрдд рдЫред рдлреЗрд░рд┐ рдкреНрд░рдпрд╛рд╕ рдЧрд░реНрдиреБрд╣реЛрд╕реН!",
    fallback: "рдо рдЬрд╡рд╛рдл рд╕реЛрдЪреНрди рд╕рдХрд┐рдирдБ ЁЯШЕ",
  },
  ╪з╪▒╪п┘И: {
    title: "╪в┘Б ┌й┘Д╪з╪│ ╪з█Т ╪в╪ж█М",
    subtitle: "╪│┘И╪з┘Д ┘╛┘И┌Ж┌╛█М┌║█Ф ╪п┘И╪│╪к╪з┘Ж█Б ┘Е╪п╪п ┘╛╪з╪ж█М┌║█Ф",
    placeholder: "╪з┘╛┘Ж╪з ╪│┘И╪з┘Д ┘Д┌й┌╛█М┌║тАж",
    greeting: "╪│┘Д╪з┘Е! ┘Е█М┌║ Offklass AI █Б┘И┌║█Ф ╪з┘╛┘Ж█М ╪м┘Е╪з╪╣╪к ╪з┘И╪▒ ╪в╪м ┌й█М╪з ╪│█М┌й┌╛┘Ж╪з ┌Ж╪з█Б╪к█Т █Б█М┌║ ╪и╪к╪з╪ж█М┌║ ЁЯдЧ",
    aiBusy: "тЪая╕П ╪з█Т ╪в╪ж█М ┘Е╪╡╪▒┘И┘Б █Б█Т█Ф ╪п┘И╪и╪з╪▒█Б ┌й┘И╪┤╪┤ ┌й╪▒█М┌║!",
    fallback: "┘Е█М┌║ ╪м┘И╪з╪и ╪│┘И┌Ж ┘Ж█Б█М┌║ ╪│┌й╪з ЁЯШЕ",
  },
  ржмрж╛ржВрж▓рж╛: {
    title: "ржЕржлржХрзНрж▓рж╛рж╕ ржПржЖржЗ",
    subtitle: "ржкрзНрж░рж╢рзНржи ржХрж░рзБржиред ржмржирзНржзрзБрж╕рзБрж▓ржн рж╕рж╣рж╛ржпрж╝рждрж╛ ржкрж╛ржиред",
    placeholder: "ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржи рж▓рж┐ржЦрзБржитАж",
    greeting: "рж╣рж╛ржЗ! ржЖржорж┐ Offklass AIред ржЖржкржирж╛рж░ ржХрзНрж▓рж╛рж╕ ржУ ржЖржЬ ржХрзА рж╢рж┐ржЦрждрзЗ ржЪрж╛ржи ржмрж▓рзБржи ЁЯдЧ",
    aiBusy: "тЪая╕П ржПржЖржЗ ржмрзНржпрж╕рзНрждред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи!",
    fallback: "ржЖржорж┐ ржХрзЛржирзЛ ржЙрждрзНрждрж░ ржнрж╛ржмрждрзЗ ржкрж╛рж░рж┐ржирж┐ ЁЯШЕ",
  },
  рд╣рд┐рдиреНрджреА: {
    title: "рдСрдлрдХреНрд▓рд╛рд╕ рдПрдЖрдИ",
    subtitle: "рдкреНрд░рд╢реНрди рдкреВрдЫреЗрдВред рджреЛрд╕реНрддрд╛рдирд╛ рдорджрдж рдкрд╛рдПрдБред",
    placeholder: "рдЕрдкрдирд╛ рдкреНрд░рд╢реНрди рд▓рд┐рдЦреЗрдВтАж",
    greeting: "рд╣рд╛рдп! рдореИрдВ Offklass AI рд╣реВрдБред рдЕрдкрдиреА рдХрдХреНрд╖рд╛ рдФрд░ рдЖрдЬ рдХреНрдпрд╛ рд╕реАрдЦрдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ рдмрддрд╛рдЗрдП ЁЯдЧ",
    aiBusy: "тЪая╕П рдПрдЖрдИ рд╡реНрдпрд╕реНрдд рд╣реИред рдлрд┐рд░ рд╕реЗ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ!",
    fallback: "рдореИрдВ рдЙрддреНрддрд░ рдирд╣реАрдВ рд╕реЛрдЪ рдкрд╛рдпрд╛ ЁЯШЕ",
  },
};

const STORE_KEY = "chat:offklass";

/* -------------------------------- Component -------------------------------- */
export default function OffklassAI() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [sending, setSending] = useState(false);
  const listRef = useRef<FlatList<Message>>(null);

  // language
  const [lang, setLang] = useState<Lang>("English");
  const T = useMemo(() => L10N[lang], [lang]);
  const isRTL = lang === "╪з╪▒╪п┘И";
  const rtl = isRTL ? ({ writingDirection: "rtl" as "rtl", textAlign: "right" as const }) : undefined;

  // Load language first, then history (so greeting localizes)
  useEffect(() => {
    (async () => {
      const ob = await loadJSON<OnboardingData | null>(ONBOARD_KEY, null);
      const savedLang = (ob?.language as Lang) || "English";
      const finalLang = LANGS.includes(savedLang) ? savedLang : "English";
      setLang(finalLang);

      const defaults: Message[] = [
        { id: "greet1", role: "assistant", content: (L10N[finalLang] ?? L10N.English).greeting },
      ];
      const saved = await loadJSON<unknown>(STORE_KEY, defaults);
      const arr = Array.isArray(saved) ? (saved as any[]) : defaults;
      const clean: Message[] = arr
        .map((m) => ({
          id: String(m?.id ?? Date.now()),
          role: m?.role === "user" || m?.role === "assistant" ? m.role : "assistant",
          content: typeof m?.content === "string" ? m.content : JSON.stringify(m?.content ?? ""),
        }))
        .slice(-100);
      setMessages(clean);
    })();
  }, []);

  // Persist on change
  useEffect(() => { try { saveJSON(STORE_KEY, messages); } catch {} }, [messages]);

  async function onSend() {
    const text = input.trim();
    if (!text || sending) return;

    setInput("");
    const userMsg: Message = { id: Date.now().toString(), role: "user", content: text };

    // Show user + typing bubble immediately
    setMessages((m) => [
      ...m,
      userMsg,
      { id: Date.now() + "-typing", role: "assistant", content: "тАж" },
    ]);

    setSending(true);
    try {
      // Use smaller context for speed
      const context = messages.slice(-3);
      const reply = await callAI([...context, userMsg]);

      setMessages((m) =>
        m.map((msg) =>
          msg.id.endsWith("-typing")
            ? {
                ...msg,
                id: String(Date.now()), // replace typing bubble
                content: typeof reply?.content === "string" && reply.content.trim()
                  ? reply.content
                  : T.fallback,
              }
            : msg
        )
      );

      requestAnimationFrame(() => listRef.current?.scrollToEnd({ animated: true }));
    } catch (e) {
      console.warn("AI call failed:", e);
      setMessages((m) =>
        m.map((msg) =>
          msg.id.endsWith("-typing")
            ? { ...msg, id: Date.now() + "-err", content: T.aiBusy }
            : msg
        )
      );
    } finally {
      setSending(false);
    }
  }

  return (
    <ErrorBoundary>
      <KeyboardAvoidingView
        style={{ flex: 1, backgroundColor: Colors.bg }}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
        keyboardVerticalOffset={80}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={[styles.title, rtl]}>{T.title}</Text>
          <Text style={[styles.subtitle, rtl]}>{T.subtitle}</Text>
        </View>

        {/* Chat */}
        <FlatList
          ref={listRef}
          data={messages}
          keyExtractor={(m) => m.id}
          renderItem={({ item }) => (
            <View style={{ paddingHorizontal: 16, paddingTop: 6 }}>
              <ChatBubble role={item.role === "user" ? "user" : "assistant"} text={item.content} />
            </View>
          )}
          contentContainerStyle={{ paddingBottom: 12 }}
          keyboardShouldPersistTaps="handled"
          onContentSizeChange={() => listRef.current?.scrollToEnd({ animated: true })}
          initialNumToRender={12}
          windowSize={10}
          removeClippedSubviews
        />

        {/* Input */}
        <View style={styles.inputBar}>
          <TextInput
            style={[styles.input, rtl]}
            placeholder={T.placeholder}
            placeholderTextColor="#9CA3AF"
            value={input}
            onChangeText={setInput}
            multiline
          />
          <Pressable
            onPress={onSend}
            disabled={sending || !input.trim()}
            style={[styles.sendBtn, (sending || !input.trim()) && { opacity: 0.5 }]}
          >
            <Ionicons name="send" size={18} color="white" />
          </Pressable>
        </View>
      </KeyboardAvoidingView>
    </ErrorBoundary>
  );
}

const styles = StyleSheet.create({
  header: {
    backgroundColor: Colors.purple,
    padding: 16,
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
    marginBottom: 8,
  },
  title: { color: "white", fontSize: 20, fontWeight: "800" },
  subtitle: { color: "white", opacity: 0.9, marginTop: 2 },

  inputBar: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    backgroundColor: Colors.bg,
  },
  input: {
    flex: 1,
    minHeight: 44,
    maxHeight: 120,
    padding: 12,
    backgroundColor: "white",
    borderRadius: 14,
    borderWidth: 1,
    borderColor: Colors.border,
  },
  sendBtn: {
    width: 44,
    height: 44,
    borderRadius: 12,
    backgroundColor: Colors.purple,
    alignItems: "center",
    justifyContent: "center",
  },
});